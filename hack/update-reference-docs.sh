#!/usr/bin/env bash
set -euo pipefail

SCRIPT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
CRD_REF_DOCS_PKG="./vendor/github.com/elastic/crd-ref-docs"
GENERATED_DOC_HEADER="<!-- Code generated by hack/update-reference-docs.sh using github.com/elastic/crd-ref-docs. DO NOT EDIT. -->"
MKDOCS_API_NAV_BEGIN="          # BEGIN GENERATED API NAV"
MKDOCS_API_NAV_END="          # END GENERATED API NAV"
APISERVICE_MANIFEST="deploy/apiserver-apiservice.yaml"

declare -A EXPECTED_GENERATED_DOCS=()
declare -a API_NAV_ENTRIES=()
declare -a TEMP_FILES=()

fail() {
	echo "$1" >&2
	exit 1
}

assert_dir() {
	local path="$1"
	if [[ ! -d "${path}" ]]; then
		fail "assertion failed: expected directory at ${path}"
	fi
}

assert_file() {
	local path="$1"
	if [[ ! -f "${path}" ]]; then
		fail "assertion failed: expected file at ${path}"
	fi
}

track_temp_file() {
	local path="$1"
	TEMP_FILES+=("${path}")
}

cleanup_temp_files() {
	local path
	if [[ "${#TEMP_FILES[@]}" -eq 0 ]]; then
		return
	fi
	for path in "${TEMP_FILES[@]}"; do
		if [[ -n "${path}" && -e "${path}" ]]; then
			rm -f "${path}"
		fi
	done
}

lower() {
	local value="$1"
	printf '%s' "${value}" | tr '[:upper:]' '[:lower:]'
}

discover_root_kinds() {
	local source_path="$1"
	local source_dir="${SCRIPT_ROOT}/${source_path}"
	assert_dir "${source_dir}"

	local marker_count=0
	local kind
	local file
	local line
	local go_type
	declare -A kind_to_go_type=()

	while IFS=: read -r file line _; do
		marker_count=$((marker_count + 1))
		kind="$(awk -v start="${line}" '
			NR < start { next }
			/^[[:space:]]*type[[:space:]]+[[:alnum:]_]+[[:space:]]+struct[[:space:]]*\{/ {
				print $2
				exit
			}
		' "${file}")"

		if [[ -z "${kind}" ]]; then
			fail "assertion failed: unable to parse kind after +kubebuilder:object:root=true in ${file}:${line}"
		fi

		if [[ "${kind}" == *List ]]; then
			continue
		fi

		go_type="${file#${SCRIPT_ROOT}/}"
		if [[ -v kind_to_go_type["${kind}"] && "${kind_to_go_type[${kind}]}" != "${go_type}" ]]; then
			fail "assertion failed: kind ${kind} discovered in multiple files (${kind_to_go_type[${kind}]}, ${go_type})"
		fi
		kind_to_go_type["${kind}"]="${go_type}"
	done < <(grep -RIn --include='*.go' -- '\+kubebuilder:object:root=true' "${source_dir}" || true)

	if [[ "${marker_count}" -eq 0 ]]; then
		fail "assertion failed: expected +kubebuilder:object:root=true markers under ${source_path}"
	fi
	if [[ "${#kind_to_go_type[@]}" -eq 0 ]]; then
		fail "assertion failed: expected at least one non-List root kind under ${source_path}"
	fi

	for kind in "${!kind_to_go_type[@]}"; do
		printf '%s\t%s\n' "${kind}" "${kind_to_go_type[${kind}]}"
	done | sort -t $'\t' -k1,1
}

find_crd_file_for_kind() {
	local kind="$1"
	local file
	local -a matches=()

	while IFS= read -r file; do
		if [[ -z "${file}" ]]; then
			continue
		fi
		matches+=("${file#${SCRIPT_ROOT}/}")
	done < <(grep -RIl --include='*.yaml' -E "^[[:space:]]+kind:[[:space:]]*${kind}[[:space:]]*$" "${SCRIPT_ROOT}/config/crd/bases" || true)

	if [[ "${#matches[@]}" -gt 1 ]]; then
		fail "assertion failed: expected at most one CRD manifest for kind ${kind}, found ${#matches[@]} (${matches[*]})"
	fi
	if [[ "${#matches[@]}" -eq 1 ]]; then
		printf '%s\n' "${matches[0]}"
	fi
}

extract_crd_field() {
	local crd_file="$1"
	local field="$2"
	local value

	value="$(awk -v field="${field}" '$1 == field":" { print $2; exit }' "${SCRIPT_ROOT}/${crd_file}")"
	if [[ -z "${value}" ]]; then
		fail "assertion failed: expected ${field}: field in ${crd_file}"
	fi

	printf '%s\n' "${value}"
}

crd_plural() {
	local crd_file="$1"
	extract_crd_field "${crd_file}" "plural"
}

crd_scope() {
	local crd_file="$1"
	local scope
	scope="$(extract_crd_field "${crd_file}" "scope")"
	lower "${scope}"
}

find_storage_for_kind() {
	local kind="$1"
	local file
	local -a matches=()

	while IFS= read -r file; do
		if [[ -z "${file}" ]]; then
			continue
		fi
		matches+=("${file#${SCRIPT_ROOT}/}")
	done < <(grep -RIl --include='*.go' -E "Kind:[[:space:]]*\"${kind}\"" "${SCRIPT_ROOT}/internal/aggregated/storage" || true)

	if [[ "${#matches[@]}" -gt 1 ]]; then
		fail "assertion failed: expected at most one aggregated storage file for kind ${kind}, found ${#matches[@]} (${matches[*]})"
	fi
	if [[ "${#matches[@]}" -eq 1 ]]; then
		printf '%s\n' "${matches[0]}"
	fi
}

generate_kind_doc() {
	local source_path="$1"
	local output_path="$2"
	local kind="$3"
	shift 3

	GOFLAGS=-mod=vendor go run "${CRD_REF_DOCS_PKG}" \
		--renderer=markdown \
		--config="${SCRIPT_ROOT}/hack/crd-ref-docs/config.yaml" \
		--templates-dir="${SCRIPT_ROOT}/hack/crd-ref-docs/templates/markdown" \
		--source-path="${SCRIPT_ROOT}/${source_path}" \
		--output-mode=single \
		--output-path="${SCRIPT_ROOT}/${output_path}" \
		--template-value="kind=${kind}" \
		"$@"
}

normalize_generated_doc_spacing() {
	local output_path="$1"
	local full_path="${SCRIPT_ROOT}/${output_path}"
	local temp_file

	assert_file "${full_path}"

	temp_file="$(mktemp)"
	track_temp_file "${temp_file}"

	awk '
		BEGIN {
			blank_count = 0
		}
		{
			if ($0 ~ /^[[:space:]]*$/) {
				blank_count += 1
				if (blank_count > 1) {
					next
				}
				print ""
				next
			}
			blank_count = 0
			print
		}
	' "${full_path}" >"${temp_file}"

	mv "${temp_file}" "${full_path}"
}

generate_docs_for_source() {
	local source_path="$1"
	local source_kind="$2"
	local require_crd="$3"
	local kind_count=0
	local kind
	local go_type
	local output_path
	local crd_file
	local resource
	local scope
	local storage_file

	while IFS=$'\t' read -r kind go_type; do
		if [[ -z "${kind}" || -z "${go_type}" ]]; then
			fail "assertion failed: malformed kind discovery record for source path ${source_path}"
		fi
		kind_count=$((kind_count + 1))

		output_path="docs/reference/api/$(lower "${kind}").md"
		if [[ -v EXPECTED_GENERATED_DOCS["${output_path}"] ]]; then
			fail "assertion failed: duplicate generated docs output path ${output_path}"
		fi

		crd_file="$(find_crd_file_for_kind "${kind}")"
		if [[ -z "${crd_file}" ]]; then
			if [[ "${require_crd}" == "true" ]]; then
				fail "assertion failed: missing CRD manifest for required kind ${kind}"
			fi
			resource="$(lower "${kind}")s"
			scope="namespaced"
		else
			resource="$(crd_plural "${crd_file}")"
			scope="$(crd_scope "${crd_file}")"
		fi

		local -a template_values=(
			"--template-value=goType=${go_type}"
			"--template-value=resource=${resource}"
			"--template-value=scope=${scope}"
		)

		case "${source_kind}" in
		controller)
			if [[ -z "${crd_file}" ]]; then
				fail "assertion failed: missing generated CRD path for controller kind ${kind}"
			fi
			template_values+=("--template-value=generatedCRD=${crd_file}")
			;;
		aggregated)
			storage_file="$(find_storage_for_kind "${kind}")"
			if [[ -n "${storage_file}" ]]; then
				template_values+=("--template-value=storage=${storage_file}")
			fi
			template_values+=("--template-value=apiServiceManifest=${APISERVICE_MANIFEST}")
			;;
		*)
			fail "assertion failed: unsupported source kind ${source_kind}"
			;;
		esac

		generate_kind_doc "${source_path}" "${output_path}" "${kind}" "${template_values[@]}"
		normalize_generated_doc_spacing "${output_path}"
		EXPECTED_GENERATED_DOCS["${output_path}"]=1
		API_NAV_ENTRIES+=("          - ${kind}: reference/api/$(lower "${kind}").md")
	done < <(discover_root_kinds "${source_path}")

	if [[ "${kind_count}" -eq 0 ]]; then
		fail "assertion failed: expected at least one generated kind under ${source_path}"
	fi
}

prune_stale_generated_docs() {
	local doc_file
	local relative_path

	shopt -s nullglob
	for doc_file in "${SCRIPT_ROOT}"/docs/reference/api/*.md; do
		relative_path="${doc_file#${SCRIPT_ROOT}/}"
		if ! grep -Fq "${GENERATED_DOC_HEADER}" "${doc_file}"; then
			continue
		fi
		if [[ -v EXPECTED_GENERATED_DOCS["${relative_path}"] ]]; then
			continue
		fi
		rm -f "${doc_file}"
	done
	shopt -u nullglob
}

sync_mkdocs_api_nav() {
	local nav_entries_file="$1"
	local mkdocs_file="${SCRIPT_ROOT}/mkdocs.yml"
	local begin_count
	local end_count
	local begin_line
	local end_line
	local temp_file

	assert_file "${mkdocs_file}"

	begin_count="$(grep -Fc "${MKDOCS_API_NAV_BEGIN}" "${mkdocs_file}")"
	if [[ "${begin_count}" -ne 1 ]]; then
		fail "assertion failed: expected exactly one '${MKDOCS_API_NAV_BEGIN}' marker in ${mkdocs_file}"
	fi
	end_count="$(grep -Fc "${MKDOCS_API_NAV_END}" "${mkdocs_file}")"
	if [[ "${end_count}" -ne 1 ]]; then
		fail "assertion failed: expected exactly one '${MKDOCS_API_NAV_END}' marker in ${mkdocs_file}"
	fi

	begin_line="$(grep -nF "${MKDOCS_API_NAV_BEGIN}" "${mkdocs_file}" | cut -d: -f1)"
	end_line="$(grep -nF "${MKDOCS_API_NAV_END}" "${mkdocs_file}" | cut -d: -f1)"
	if [[ -z "${begin_line}" || -z "${end_line}" || "${begin_line}" -ge "${end_line}" ]]; then
		fail "assertion failed: expected '${MKDOCS_API_NAV_BEGIN}' to appear before '${MKDOCS_API_NAV_END}' in ${mkdocs_file}"
	fi

	temp_file="$(mktemp)"
	track_temp_file "${temp_file}"

	awk -v begin="${MKDOCS_API_NAV_BEGIN}" -v end="${MKDOCS_API_NAV_END}" -v nav_entries_file="${nav_entries_file}" '
		$0 == begin {
			print
			while ((getline nav_line < nav_entries_file) > 0) {
				print nav_line
			}
			close(nav_entries_file)
			in_generated_block = 1
			next
		}
		$0 == end {
			in_generated_block = 0
			print
			next
		}
		in_generated_block {
			next
		}
		{
			print
		}
	' "${mkdocs_file}" >"${temp_file}"

	mv "${temp_file}" "${mkdocs_file}"
}

assert_dir "${SCRIPT_ROOT}/api/v1alpha1"
assert_dir "${SCRIPT_ROOT}/api/aggregation/v1alpha1"
assert_dir "${SCRIPT_ROOT}/config/crd/bases"
assert_dir "${SCRIPT_ROOT}/docs/reference/api"
assert_dir "${SCRIPT_ROOT}/hack/crd-ref-docs/templates/markdown"
assert_dir "${SCRIPT_ROOT}/internal/aggregated/storage"
assert_dir "${SCRIPT_ROOT}/vendor/github.com/elastic/crd-ref-docs"
assert_file "${SCRIPT_ROOT}/hack/crd-ref-docs/config.yaml"
assert_file "${SCRIPT_ROOT}/hack/crd-ref-docs/templates/markdown/gv_list.tpl"
assert_file "${SCRIPT_ROOT}/mkdocs.yml"
assert_file "${SCRIPT_ROOT}/${APISERVICE_MANIFEST}"

trap cleanup_temp_files EXIT

cd "${SCRIPT_ROOT}"
generate_docs_for_source "api/v1alpha1" "controller" "true"
generate_docs_for_source "api/aggregation/v1alpha1" "aggregated" "false"
prune_stale_generated_docs

if [[ "${#API_NAV_ENTRIES[@]}" -eq 0 ]]; then
	fail "assertion failed: expected at least one API nav entry"
fi

api_nav_entries_file="$(mktemp)"
track_temp_file "${api_nav_entries_file}"
printf '%s\n' "${API_NAV_ENTRIES[@]}" >"${api_nav_entries_file}"
sync_mkdocs_api_nav "${api_nav_entries_file}"
